#!/bin/bash

# Copyright (c) 2014 Julien Limoges
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
BASENAME=$(basename $0)

OPT_MUST_SAVE=false
OPT_SAVE_PATH=''
OPT_VERBOSE=false

broadcast()
{
    local targets="${@:2}"
    local typed="$1"
    for pane_id in $targets; do
        tmux send-keys -t "$pane_id" "$typed"
    done
}

get_broadcast_source()
{
    local all_panes=$(echo $(tmux list-panes -F '#{pane_id}'))
    local self_index=$(echo $(tmux display-message -p '#P'))
    # The cut indexes start from 1
    local cut_index=$((self_index+1))
    local pane_id=$(echo $all_panes | cut -d ' ' -f $cut_index)

    echo $pane_id
    return 0
}

get_broadcast_targets()
{
    local desired="$@"
    local all_panes=$(echo $(tmux list-panes -F '#{pane_id}'))
    local nb_panes=$(echo "$all_panes" | wc -w)
    local self_index=$(echo $(tmux display-message -p '#P'))
    local translated=

    for pane_index in $desired; do
        if [[ "$pane_index" -ge "$nb_panes" ]]; then
            # Over upper bound
            echo "error: only $nb_panes in window but index '$pane_index' was given"
            return 1
        fi
        if [[ "$pane_index" -eq "$self_index" ]]; then
            echo "error: cannot broadcast from '$self_index' to '$pane_index' (loop)"
            return 1
        fi
        # The cut indexes start from 1
        local cut_index=$((pane_index+1))
        local pane_id=$(echo $all_panes | cut -d ' ' -f $cut_index)
        translated="$translated $pane_id"
    done
    echo $translated
    return 0
}

KEYPRESS=''
read_key()
{
    local key1=
    local key2=
    local key3=
    
    # We read from 1 up to 4 characters. The reason for the characters 2-4 is
    # for escaped sequence of characters.
    # The first read is blocking. Upon input we test for an escaped sequence.
    unset key1 key2 key3
    # Rapidly get the keys after blocking read
    read -r -N1          2>/dev/null
    key1="$REPLY"
    read -r -N2 -t 0.001 2>/dev/null
    key2="$REPLY"
    read -r -N1 -t 0.001 2>/dev/null
    key3="$REPLY"

    # We use a global because this seems to be the only way
    # to make enter work.
    KEYPRESS="$key1$key2$key3"
    #printf "keypress read \\\x%02x\n" "'${key1}" 1>&2
    return 0
}

is_inside_tmux()
{
    if ! { [ "$TERM" = "screen" ] && [ -n "$TMUX" ]; } then
        return 0
    fi
    return 1
}

handle_args()
{
    if [[ "$OPT_MUST_SAVE" == true ]]; then
        # Truncate save path to new file
        echo -n "" > $OPT_SAVE_PATH
        if [[ "$OPT_VERBOSE" == true ]]; then
            echo "saving commands to '$OPT_SAVE_PATH'"
        fi
    fi
}

main()
{
    if [ $# -lt 1 ]; then
        echo 'bcast: missing pane index operand'
        echo 'usage: bcast INDEX...'
        echo '  INDEX is the pane index which should receive the broadcasted keypresses'
        exit
    fi

    if [ ! is_inside_tmux ]; then
        echo 'error: program is meant to be run inside a tmux session'
        exit
    fi

    local args=$(getopt -o 's:v' -l 'save:verbose' -n "$BASENAME" -- "$@")
    # Handle options
    if [ $? -ne 0 ]; then
        exit 1
    fi
    eval set -- "$args"

    # Options
    # Extract options and their arguments
    while true; do
        case "$1" in
            -s|--save)
                shift;
                case "$1" in
                    "")
                        shift
                    ;;
                    *)
                        OPT_MUST_SAVE=true
                        OPT_SAVE_PATH="$1"
                        shift
                    ;;
                esac
            ;;
            -v|--verbose)
                OPT_VERBOSE=true
                shift;
            ;;
            --)
                shift
                break
            ;;
        esac
    done


    local desired="$@"
    local sourcep=$(get_broadcast_source)
    local targetp=""
    if targetp=$(get_broadcast_targets $desired); then
        : noop
    else
        echo "$targetp"
        exit
    fi

    # Prepare the environment for execution
    handle_args

    # Set terminal to not echo characters because we want control of stdout
    stty -echo

    while true; do
        read_key
        local echop="$KEYPRESS"
        local typed="$KEYPRESS"
        #printf "keypress received \\\x%02x\n" "'${typed}" 1>&2

        # Special behaviour handling
        # e.g. implementing backspace functionality on input pane
        case "$typed" in
            # Up
            $'\x1b\x5b\x41') 
                # Disable up on input pane
                echop=''
            ;;
            # Down
            $'\x1b\x5b\x42') 
                # Disable down on input pane
                echop=''
            ;;
            # Tab
            $'\x09')
                # Disable tab on input pane
                echop=''
            ;;
            # Backspace
            $'\x08')
                # Backspace should work as intended on the input pane
                echop="$echop\033[K"
            ;;
        esac
        if [[ "$OPT_MUST_SAVE" == 'true' ]]; then
            echo -en "$echop" >> $OPT_SAVE_PATH
        fi
        echo -en "$echop"
        broadcast "$typed" $targetp
    done
}

# Emulate a program main to have better flow control throughout the program
main $@

